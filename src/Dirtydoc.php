<?php
/**
 * Dirtydoc
 * Simple and dirty markdown documentation generator for specific class, based on public methods and docblocks
 * 2019 resist | https://resist.hu
 * Based on https://github.com/kamermans/docblock-reflection/
 */

namespace resist;

use \H3;
use \ReflectionClass;
use \ReflectionException;
use \ReflectionMethod;
use \SplFileObject;

class Dirtydoc
{
    private string $className;
    private string $namespace;
    private array $methods;
    private ReflectionClass $reflection;
    private string $generatedMd;

    public function __construct(string $className, string $title = 'Usage')
    {
        $this->setClass($className);
        $this->reflection = new ReflectionClass($this->className);
        $this->setNamespace();
        $this->setMethods();
        $this->setApidoc($title);
    }

    private function setClass(string $className): void
    {
        if (preg_match('^[a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*(\\\\[a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*)*$', $className)) {
            $this->className = $className;
        } else {
            throw new \Exception('Invalid class name');
        }

    }

    private function setNamespace(): void
    {
        $this->namespace = $this->reflection->getNamespaceName();
    }

    private function setMethods(): void
    {
        $this->methods = $this->reflection->getMethods(ReflectionMethod::IS_PUBLIC);
    }

    /**
     * Render and save documentation
     * @param string $title Set markdown header2 of documentation
     */
    private function setApidoc(string $title = 'Usage'): void
    {
        $res = '## '. H3::makeMdStrict($title)."\n\n";
        $res .= 'Public methods of ***'.$this->className."***  \n[Autogenerated](https://github.com/r3sist/apidoc) at ".date('Y-m-d', time())." \n\n";

        $classDocblock = $this->reflection->getDocComment();
        $parsedClassDocblock = $this->parseDocBlock($classDocblock);
        $res .= '> '.$parsedClassDocblock['description']."\n\n";

        foreach ($this->methods as $method) {
            /** @var $method ReflectionMethod */
            $methodName = $method->getName();
            $methodStartLine = $method->getStartLine();
            $methodDocblock = $method->getDocComment();
            $parsedDocblock = $this->parseDocBlock($methodDocblock);

            $res .= "### ".$methodName."()\n\n";
            $res .= '> '.$parsedDocblock['description']."\n\n";

            $file = new SplFileObject($method->getFileName());
            $file->seek($methodStartLine - 2);
            $res .= "```php\n".trim($file->fgets())."\n```\n";

            $res .= "\n".'| tag | value | comment |'."\n".'| :---: | :--- | ---: |'."\n";
            if (!empty($parsedDocblock['tags'])) {
                foreach ($parsedDocblock['tags'] as $tags) {
                    foreach ($tags as $tag => $comment) {
                        // \$[a-zA-z0-9-_]*_priv\b
                        $comment = preg_replace('/\$([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)/', '**$${1}**%%%', $comment);
                        $comment = strtr($comment, ['string ' => '`string` ', 'int ' => '`int` ', 'bool ' => '`bool` ', 'float ' => '`float` ', 'double ' => '`double` ', 'mixed ' => '`mixed` ', 'array ' => '`array` ', 'object ' => '`object` ', 'void ' => '`void` ']);
                        $comment = explode('%%%', $comment);
                        $res .= '| *'.$tag.'* | '.($comment[0] != ''?$comment[0]:'').' | '.$comment[1].' |';
                    }
                    $res .= "\n";
                }
            }

            $res .= "\n";
        }

        $this->generatedMd = $res;
    }

    /**
     * Return documentation
     * @return string $apidoc Markdown text of documentation
     */
    public function getGeneratedMd()
    {
        return $this->generatedMd;
    }

    /**
     * Save file as given name, e.g.: USAGE.md
     * @param string $fileName Name of saved documentation file
     */
    public function saveFile($fileName = 'USAGE.md')
    {
        $fileName = V3::clean($fileName, 'path');
        file_put_contents($fileName, $this->getGeneratedMd());
    }

    /**
     * Parse docblock
     * @param $methodDocblock
     * @return array|void
     */
    private function parseDocBlock($methodDocblock)
    {
        $res = [
            'description' => '',
            'tags' => []
        ];

        $methodDocblock = str_replace("\r\n", "\n", $methodDocblock);
        $lines = explode("\n", $methodDocblock);

        switch (count($lines)) {
            case 1:
                // handle single-line docblock
                if (!preg_match('#\\/\\*\\*([^*]*)\\*\\/#', $lines[0], $matches)) {
                    return;
                }
                // remove start-end characters
                $lines[0] = substr($lines[0], 3, -2);
                break;
            case 2:
                // probably malformed
                return;
            default:
                // handle multi-line docblock, remove first and last lines
                array_shift($lines);
                array_pop($lines);
                break;
        }

        foreach ($lines as $line) {
            $line = preg_replace('#^[ \t\*]*#', '', $line);
            if (strlen($line) < 2) {
                continue;
            }
            if (preg_match('#@([^ ]+)(.*)#', $line, $matches)) {
                $tagName = $matches[1];
                $tagValue = trim($matches[2]);
                $tag = [$tagName => $tagValue];
                array_push($res['tags'], $tag);
                continue;
            }
            $res['description'].= trim($line)."\n";
        }
        return $res;
    }
}
