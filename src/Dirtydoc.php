<?php
/**
 * Apidoc
 * Simple and dirty markdown documentation generator for specific class, based on public methods and docblocks
 * https://github.com/r3sist/Apidoc
 * 2019 Bence VÁNKOS | https://resist.hu
 * Based on https://github.com/kamermans/docblock-reflection/
 */

namespace resist;

use \H3;
use \ReflectionClass;
use \ReflectionException;
use \ReflectionMethod;
use \SplFileObject;
use \V3;

/**
 * @package resist
 */
class Apidoc
{
    /** @var string $class Contains documented classname */
    private $class;

    /** @var ReflectionClass */
    private $reflection;

    /** @var string $namespace Contains class namespace */
    private $namespace;

    /** @var mixed $methods contains class' methods */
    private $methods;

    /** @var string $apidoc contains MD documentation */
    private $apidoc;

    /**
     * Apidoc constructor
     * @param string $className Generate documentation for this class. e.g.: `'\resist\Apidoc'`
     * @param string $title Sets MD ## header of documentation
     * @throws ReflectionException
     */
    public function __construct(string $className, string $title = 'Usage')
    {
        $this->setClass($className);
        $this->setReflection();
        $this->setNamespace();
        $this->setMethods();
        $this->setApidoc($title);
    }

    /**
     * Set Class name
     * @param string $class Class name to be documented
     */
    private function setClass($class): void
    {
        $this->class = V3::clean($class, 'class');
    }

    /**
     * Set Reflection class
     * @throws ReflectionException
     */
    private function setReflection(): void
    {
        $this->reflection = new ReflectionClass($this->class);
    }

    /**
     * Set namespace
     */
    private function setNamespace(): void
    {
        $this->namespace = $this->reflection->getNamespaceName();
    }

    /**
     * Set methods
     */
    private function setMethods(): void
    {
        $this->methods = $this->reflection->getMethods(ReflectionMethod::IS_PUBLIC);
    }

    /**
     * Return the methods of class
     * @return mixed $methods Object contains list of methods
     */
    public function getMethods()
    {
        return $this->methods;
    }

    /**
     * Render and save documentation
     * @param string $title Set markdown header2 of documentation
     */
    private function setApidoc(string $title = 'Usage'): void
    {
        $res = '## '. H3::makeMdStrict($title)."\n\n";
        $res .= 'Public methods of ***'.$this->class."***  \n[Autogenerated](https://github.com/r3sist/apidoc) at ".date('Y-m-d', time())." \n\n";

        $classDocblock = $this->reflection->getDocComment();
        $parsedClassDocblock = $this->parseDocBlock($classDocblock);
        $res .= '> '.$parsedClassDocblock['description']."\n\n";

        foreach ($this->methods as $method) {
            /** @var $method ReflectionMethod */
            $methodName = $method->getName();
            $methodStartLine = $method->getStartLine();
            $methodDocblock = $method->getDocComment();
            $parsedDocblock = $this->parseDocBlock($methodDocblock);

            $res .= "### ".$methodName."()\n\n";
            $res .= '> '.$parsedDocblock['description']."\n\n";

            $file = new SplFileObject($method->getFileName());
            $file->seek($methodStartLine - 2);
            $res .= "```php\n".trim($file->fgets())."\n```\n";

            $res .= "\n".'| tag | value | comment |'."\n".'| :---: | :--- | ---: |'."\n";
            if (!empty($parsedDocblock['tags'])) {
                foreach ($parsedDocblock['tags'] as $tags) {
                    foreach ($tags as $tag => $comment) {
                        // \$[a-zA-z0-9-_]*_priv\b
                        $comment = preg_replace('/\$([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)/', '**$${1}**%%%', $comment);
                        $comment = strtr($comment, ['string ' => '`string` ', 'int ' => '`int` ', 'bool ' => '`bool` ', 'float ' => '`float` ', 'double ' => '`double` ', 'mixed ' => '`mixed` ', 'array ' => '`array` ', 'object ' => '`object` ', 'void ' => '`void` ']);
                        $comment = explode('%%%', $comment);
                        $res .= '| *'.$tag.'* | '.($comment[0] != ''?$comment[0]:'').' | '.$comment[1].' |';
                    }
                    $res .= "\n";
                }
            }

            $res .= "\n";
        }

        $this->apidoc = $res;
    }

    /**
     * Return documentation
     * @return string $apidoc Markdown text of documentation
     */
    public function getApidoc()
    {
        return $this->apidoc;
    }

    /**
     * Save file as given name, e.g.: USAGE.md
     * @param string $fileName Name of saved documentation file
     */
    public function saveFile($fileName = 'USAGE.md')
    {
        $fileName = V3::clean($fileName, 'path');
        file_put_contents($fileName, $this->getApidoc());
    }

    /**
     * Parse docblock
     * @param $methodDocblock
     * @return array|void
     */
    private function parseDocBlock($methodDocblock)
    {
        $res = [
            'description' => '',
            'tags' => []
        ];

        $methodDocblock = str_replace("\r\n", "\n", $methodDocblock);
        $lines = explode("\n", $methodDocblock);

        switch (count($lines)) {
            case 1:
                // handle single-line docblock
                if (!preg_match('#\\/\\*\\*([^*]*)\\*\\/#', $lines[0], $matches)) {
                    return;
                }
                // remove start-end characters
                $lines[0] = substr($lines[0], 3, -2);
                break;
            case 2:
                // probably malformed
                return;
            default:
                // handle multi-line docblock, remove first and last lines
                array_shift($lines);
                array_pop($lines);
                break;
        }

        foreach ($lines as $line) {
            $line = preg_replace('#^[ \t\*]*#', '', $line);
            if (strlen($line) < 2) {
                continue;
            }
            if (preg_match('#@([^ ]+)(.*)#', $line, $matches)) {
                $tagName = $matches[1];
                $tagValue = trim($matches[2]);
                $tag = [$tagName => $tagValue];
                array_push($res['tags'], $tag);
                continue;
            }
            $res['description'].= trim($line)."\n";
        }
        return $res;
    }
}
